EXPORT_SYMBOL(GROUPS_ALLOC); 											435454654654654		456465X			0000000
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 								1253135		9034598			0000000
NBLOCKS = (GIDSETSIZE 2>!@)														4vv3444		7955345			0000000
GROUP_INFO->BLOCKS

~white-STRUCT GROUP_INFO INIT_GROUPS = { .USAGE = ATOMIC_INIT(2) }; STRUCT GROUP_INFO *GROUPS_ALLOC(INT GIDSETSIZE){ 
	STRUCT GROUP_INFO *GROUP_INFO; 
	INT NBLOCKS; 
	INT I;	
	NBLOCKS = ~seagreen-(GIDSETSIZE + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
	~WHITE-/* MAKE SURE WE ALWAYS ALLOCATE AT LEAST ONE INDIRECT BLOCK POINTER */ 
	NBLOCKS = NBLOCKS ? : 1; 
	GROUP_INFO = KMALLOC(SIZEOF(*GROUP_INFO) + NBLOCKS*SIZEOF(GID_T *), GFP_USER); 
	IF (!GROUP_INFO) 
		RETURN NULL;	
	GROUP_INFO->NGROUPS = GIDSETSIZE; 
	GROUP_INFO->NBLOCKS = NBLOCKS; 
	ATOMIC_SET(&GROUP_INFO->USAGE, 1);	
	IF (GIDSETSIZE <= NGROUPS_SMALL) 
		GROUP_INFO->BLOCKS[0] = GROUP_INFO->SMALL_BLOCK; 
	ELSE { 
		FOR (I = 0; I < NBLOCKS; I++) { 
			GID_T *B; 
			B = (VOID *)__GET_FREE_PAGE(GFP_USER); 
			IF (!B) 
				GOTO OUT_UNDO_PARTIAL_ALLOC; 
			GROUP_INFO->BLOCKS[I] = B; 
		} 
	} 
	RETURN GROUP_INFO; 	
NBLOCKS = (GIDSETSIZE 2>!@)														4vv3444		7955345			0000000
EXPORT_SYMBOL(GROUPS_ALLOC); 											435454654654654		456465X			0000000
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 								1253135		9034598			0000000

EXPORT_SYMBOL(GROUPS_ALLOC); 											435454654654654		456465X			0000000
NBLOCKS = (GIDSETSIZE 2>!@)														4vv3444		7955345			0000000

VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 								1253135		9034598			0000000
NBLOCKS = (GIDSETSIZE 2>!@)														4vv3444		7955345			0000000

EXPORT_SYMBOL(GROUPS_ALLOC); 											435454654654654		232323x			0000000
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 								1253135		2323232			0000000
NBLOCKS = (GIDSETSIZE 2>!@)														1212222		2323123			0000000

GROUP_INFO->BLOCKS

~RED-OUT_UNDO_PARTIAL_ALLOC: 	
	~WHITE-WHILE (--I >= 0) { 	
		FREE_PAGE((UNSIGNED LONG)GROUP_INFO->BLOCKS[I]);	
	} 
	KFREE(GROUP_INFO); 	
	RETURN NULL; 	
} 	
EXPORT_SYMBOL(GROUPS_ALLOC); 
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 	
{ 	
	~seagreen-IF (GROUP_INFO->BLOCKS[0] != GROUP_INFO->SMALL_BLOCK) { 	
		~WHITE-INT I; 	
		FOR (I = 0; I < GROUP_INFO->NBLOCKS; I++)












~LONGPAUSE-
~white-STRUCT GROUP_INFO INIT_GROUPS = { .USAGE = ATOMIC_INIT(2) }; 	
STRUCT GROUP_INFO *GROUPS_ALLOC(INT GIDSETSIZE){ 
	STRUCT GROUP_INFO *GROUP_INFO; 
	INT NBLOCKS; 
	INT I; 	
	NBLOCKS = (GIDSETSIZE + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
	/* MAKE SURE WE ALWAYS ALLOCATE AT LEAST ONE INDIRECT BLOCK POINTER
	NBLOCKS = NBLOCKS ? : 1; 
	GROUP_INFO = KM(OF(*GROUP_INFO) + NBLOCKS*SIZEOF(GID_T *), GFP_USER)
	IF (!GROUP_INFO) 
		RETURN NULL; 
	GROUP_INFO->NGROUPS = GIDSETSIZE; 
	GROUP_INFO->NBLOCKS = NBLOCKS; 
	ATOMIC_SET(&GROUP_INFO->USAGE, 1);	
	IF (GIDSETSIZE <= NGROUPS_SMALL) 
		GROUP_INFO->BLOCKS[0] = GROUP_INFO->SMALL_BLOCK; 
	ELSE { 
		FOR (I = 0; I < NBLOCKS; I++) { 
			GID_T *B; 
			B = (VOID *)__GET_FREE_PAGE(GFP_USER); 
			IF (!B) 
				GOTO OUT_UNDO_PARTIAL_ALLOC; 
			GROUP_INFO->BLOCKS[I] = B; 
		} 
	} 
	RETURN GROUP_INFO; 	
OUT_UNDO_PARTIAL_ALLOC: 	
	WHILE (--I >= 0) { 	
		FREE_PAGE((UNSIGNED LONG)GROUP_INFO->BLOCKS[I]); 	
	} 	
	KFREE(GROUP_INFO); 	
	RETURN NULL; 	
} 
















EXPORT_SYMBOL(GROUPS_ALLOC); 
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 
{ 
	IF (GROUP_INFO->BLOCKS[0] != GROUP_INFO->SMALL_BLOCK) { 
		INT I; 
		FOR (I = 0; I < GROUP_INFO->NBLOCKS; I++) 
STRUCT GROUP_INFO INIT_GROUPS = { .USAGE = ATOMIC_INIT(2) }; 
STRUCT GROUP_INFO *GROUPS_ALLOC(INT GIDSETSIZE){ 
	STRUCT GROUP_INFO *GROUP_INFO; 
	INT NBLOCKS; 
	INT I; 
	NBLOCKS = (GIDSETSIZE + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
	/* MAKE SURE WE ALWAYS ALLOCATE AT LEAST ONE INDIRECT BLOCK POINTER */ 
	NBLOCKS = NBLOCKS ? : 1; 
	~lightsteelblue-GROUP_INFO = KMALLOC(SIZEOF(*GROUP_INFO) + NBLOCKS*SIZEOF(GID_T *), GFP_USER); 
	~WHITE-IF (!GROUP_INFO) 
		RETURN NULL; 
	GROUP_INFO->NGROUPS = GIDSETSIZE; 
	GROUP_INFO->NBLOCKS = NBLOCKS; 
	ATOMIC_SET(&GROUP_INFO->USAGE, 1); 
	IF (GIDSETSIZE <= NGROUPS_SMALL) 
		GROUP_INFO->BLOCKS[0] = GROUP_INFO->SMALL_BLOCK; 
	ELSE { 
		FOR (I = 0; I < NBLOCKS; I++) { 
			GID_T *B; 
			B = (VOID *)__GET_FREE_PAGE(GFP_USER); 
			IF (!B) 
				GOTO OUT_UNDO_PARTIAL_ALLOC; 
			GROUP_INFO->BLOCKS[I] = B; 
		} 
	} 
	RETURN GROUP_INFO; 
~lightsteelblue-OUT_UNDO_PARTIAL_ALLOC: 
	~WHITE-WHILE (--I >= 0) { 
		FREE_PAGE((UNSIGNED LONG)GROUP_INFO->BLOCKS[I]); 
	} 
	KFREE(GROUP_INFO); 
	RETURN NULL; 
}














~LONGPAUSE-
EXPORT_SYMBOL(GROUPS_ALLOC); 
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 
{ 
	IF (GROUP_INFO->BLOCKS[0] != GROUP_INFO->SMALL_BLOCK) { 
		INT I; 
		FOR (I = 0; I < GROUP_INFO->NBLOCKS; I++) 
	ECHO('HELLO WORLD');


EXPORT_SYMBOL(GROUPS_ALLOC); 											435454654654654		232323x			0000000
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 								1253135		2323232			0000000
NBLOCKS = (GIDSETSIZE 2>!@)														1212222		2323123			0000000

EXPORT_SYMBOL(GROUPS_ALLOC); 												0x0x0x0x0x0x	43545465		0000000
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 											1253135			0000000
NBLOCKS = (GIDSETSIZE)																		1212222			0000000
GROUP_INFO->BLOCKS