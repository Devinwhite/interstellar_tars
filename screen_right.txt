G0 X-10.121 Y-3.403 Z15.000 F500 G1 X-9.934 Y-3.475 Z-13.049 F500 G1 X-9.801 Y-3.453 Z-13.049 F500 G1 X-9.741 Y0 G1 X-9-.866 Y-3.471 Z
~green-EXPORT_SYMBOL(GROUPS_ALLOC); 									~white-GR0FO			~green-  GROUP_INFO->BLOCKS[0] = GROUP
	VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 			~white-GR0FO

			~green-G1 X-1.706 Y9.050 Z-13.049 F800								~white-GR0F2					~green-  ATOMIC
		~green-G1 X-1.706 Y9.050 Z-13.049 F800									~white-GR0F2					~green-  PARTIAL
~green-G1 X-1.706 Y9.050 Z-13.049 F800											~white-GR0F2					~green-  ALLOC
~white-G0 X-10.121 Y-3.403 Z15.000 F500 G1 X-9.934 Y-3.475 Z-13.049 F500 G1 X-9.801

~green-G1 X-1.706 Y9.050 Z-13.049 F800			~white-F2		
	~green-G1 X-1.706 Y9.050 Z-13.049 F800		~white-F2	

STRUCT GROUP_INFO INIT_GROUPS = { .USAGE = ATOMIC_INIT(2) }; STRUCT GROUP_INFO *GROUPS_ALLOC(INT GIDSETSIZE){ 
	STRUCT GROUP_INFO *GROUP_INFO; 
	INT NBLOCKS; 
	INT I;	
	NBLOCKS = ~seagreen-(GIDSETSIZE + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
	~white-/* MAKE SURE WE ALWAYS ALLOCATE AT LEAST ONE INDIRECT BLOCK POINTER */ 
	NBLOCKS = NBLOCKS ? : 1; 
	GROUP_INFO = KMALLOC(SIZEOF(*GROUP_INFO) + NBLOCKS*SIZEOF(GID_T *), GFP_USER); 
	IF (!GROUP_INFO) 
		RETURN NULL;	
	GROUP_INFO->NGROUPS = GIDSETSIZE; 
	GROUP_INFO->NBLOCKS = NBLOCKS; 
	ATOMIC_SET(&GROUP_INFO->USAGE, 1);	
	IF (GIDSETSIZE <= NGROUPS_SMALL) 
		GROUP_INFO->BLOCKS[0] = GROUP_INFO->SMALL_BLOCK; 
	ELSE { 
		~green-FOR (I = 0; I < NBLOCKS; I++) { 
			GID_T *B; 
			B = (VOID *)__GET_FREE_PAGE(GFP_USER); 
			IF (!B) 
				GOTO OUT_UNDO_PARTIAL_ALLOC; 
			~white-GROUP_INFO->BLOCKS[I] = B; 
		} 
	} 
	RETURN GROUP_INFO; 	
~green-NBLOCKS = (GIDSETSIZE 2>!@)											~white-4vv3444			7955345			0000000
~green-EXPORT_SYMBOL(GROUPS_ALLOC); 										~white-435454654654654	456465X			0000000
~green-VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 					~white-1253135			9034598			0000000

~green-EXPORT_SYMBOL(GROUPS_ALLOC); 										~white-435454654654654	456465X			0000000
~green-NBLOCKS = (GIDSETSIZE 2>!@)											~white-4vv3444			7955345			0000000

~green-VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 					~white-1253135			9034598			0000000
~green-NBLOCKS = (GIDSETSIZE 2>!@)											~white-4vv3444			7955345			0000000

~green-EXPORT_SYMBOL(GROUPS_ALLOC); 										~white-435454654654654	232323x			0000000
~green-VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 					~white-1253135			2323232			0000000
~green-NBLOCKS = (GIDSETSIZE 2>!@)											~white-1212222			2323123			0000000

GROUP_INFO->BLOCKS

~RED-OUT_UNDO_PARTIAL_ALLOC: 	
	~white-WHILE (--I >= 0) { 	
		FREE_PAGE((UNSIGNED LONG)GROUP_INFO->BLOCKS[I]);	
	} 
	KFREE(GROUP_INFO); 	
	RETURN NULL; 	
} 	
EXPORT_SYMBOL(GROUPS_ALLOC); 
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 	
{ 	
	~seagreen-IF (GROUP_INFO->BLOCKS[0] != GROUP_INFO->SMALL_BLOCK) { 	
		~white-INT I; 	
		FOR (I = 0; I < GROUP_INFO->NBLOCKS; I++)












~LONGPAUSE-
~white-STRUCT GROUP_INFO INIT_GROUPS = { .USAGE = ATOMIC_INIT(2) }; 	
STRUCT GROUP_INFO *GROUPS_ALLOC(INT GIDSETSIZE){ 
	STRUCT GROUP_INFO *GROUP_INFO; 
	INT NBLOCKS; 
	INT I; 	
	NBLOCKS = (GIDSETSIZE + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
	/* MAKE SURE WE ALWAYS ALLOCATE AT LEAST ONE INDIRECT BLOCK POINTER
	NBLOCKS = NBLOCKS ? : 1; 
	GROUP_INFO = KM(OF(*GROUP_INFO) + NBLOCKS*SIZEOF(GID_T *), GFP_USER)
	IF (!GROUP_INFO) 
		RETURN NULL; 
	GROUP_INFO->NGROUPS = GIDSETSIZE; 
	GROUP_INFO->NBLOCKS = NBLOCKS; 
	ATOMIC_SET(&GROUP_INFO->USAGE, 1);	
	IF (GIDSETSIZE <= NGROUPS_SMALL) 
		GROUP_INFO->BLOCKS[0] = GROUP_INFO->SMALL_BLOCK; 
	ELSE { 
		FOR (I = 0; I < NBLOCKS; I++) { 
			GID_T *B; 
			B = (VOID *)__GET_FREE_PAGE(GFP_USER); 
			IF (!B) 
				GOTO OUT_UNDO_PARTIAL_ALLOC; 
			GROUP_INFO->BLOCKS[I] = B; 
		} 
	} 
	RETURN GROUP_INFO; 	
OUT_UNDO_PARTIAL_ALLOC: 	
	WHILE (--I >= 0) { 	
		FREE_PAGE((UNSIGNED LONG)GROUP_INFO->BLOCKS[I]); 	
	} 	
	KFREE(GROUP_INFO); 	
	RETURN NULL; 	
} 
















~green-EXPORT_SYMBOL(GROUPS_ALLOC); 
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 
{ 
	IF (GROUP_INFO->BLOCKS[0] != GROUP_INFO->SMALL_BLOCK) { 
		INT I; 
		FOR (I = 0; I < GROUP_INFO->NBLOCKS; I++) 
STRUCT GROUP_INFO INIT_GROUPS = { .USAGE = ATOMIC_INIT(2) }; 
STRUCT GROUP_INFO *GROUPS_ALLOC(INT GIDSETSIZE){ 
	STRUCT GROUP_INFO *GROUP_INFO; 
	INT NBLOCKS; 
	INT I; 
	NBLOCKS = (GIDSETSIZE + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
	/* MAKE SURE WE ALWAYS ALLOCATE AT LEAST ONE INDIRECT BLOCK POINTER */ 
	NBLOCKS = NBLOCKS ? : 1; 
	~lightsteelblue-GROUP_INFO = KMALLOC(SIZEOF(*GROUP_INFO) + NBLOCKS*SIZEOF(GID_T *), GFP_USER); 
	~white-IF (!GROUP_INFO) 
		RETURN NULL; 
	GROUP_INFO->NGROUPS = GIDSETSIZE; 
	GROUP_INFO->NBLOCKS = NBLOCKS; 
	ATOMIC_SET(&GROUP_INFO->USAGE, 1); 
	IF (GIDSETSIZE <= NGROUPS_SMALL) 
		GROUP_INFO->BLOCKS[0] = GROUP_INFO->SMALL_BLOCK; 
	ELSE { 
		FOR (I = 0; I < NBLOCKS; I++) { 
			GID_T *B; 
			B = (VOID *)__GET_FREE_PAGE(GFP_USER); 
			IF (!B) 
				GOTO OUT_UNDO_PARTIAL_ALLOC; 
			GROUP_INFO->BLOCKS[I] = B; 
		} 
	} 
	RETURN GROUP_INFO; 
~lightsteelblue-OUT_UNDO_PARTIAL_ALLOC: 
	~white-WHILE (--I >= 0) { 
		FREE_PAGE((UNSIGNED LONG)GROUP_INFO->BLOCKS[I]); 
	} 
	KFREE(GROUP_INFO); 
	RETURN NULL; 
}














~LONGPAUSE-
EXPORT_SYMBOL(GROUPS_ALLOC); 
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 
{ 
	IF (GROUP_INFO->BLOCKS[0] != GROUP_INFO->SMALL_BLOCK) { 
		INT I; 
		FOR (I = 0; I < GROUP_INFO->NBLOCKS; I++) 
	ECHO('HELLO WORLD');


EXPORT_SYMBOL(GROUPS_ALLOC); 											435454654654654		232323x			0000000
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 								1253135		2323232			0000000
NBLOCKS = (GIDSETSIZE 2>!@)														1212222		2323123			0000000

EXPORT_SYMBOL(GROUPS_ALLOC); 												0x0x0x0x0x0x	43545465		0000000
VOID GROUPS_FREE(STRUCT GROUP_INFO *GROUP_INFO) 											1253135			0000000
NBLOCKS = (GIDSETSIZE)																		1212222			0000000
GROUP_INFO->BLOCKS